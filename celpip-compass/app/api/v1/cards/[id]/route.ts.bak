import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import {
  CardType,
  DifficultyLevel,
  CardStatus,
  Flashcard
} from '@/types/flashcards';
import { ApiResponse } from '@/types/auth';

// 模拟数据库
const mockFlashcards: Flashcard[] = [
  {
    id: '1',
    type: CardType.WRITING,
    question: '向邻居投诉噪音问题',
    answer: '尊敬的邻居，我想和您讨论一下夜间噪音的问题。最近晚上经常听到大声的音乐和说话声，这让我很难入睡。您是否可以降低音量或调整活动时间？谢谢您的理解和配合。',
    explanation: 'This is a formal complaint about noise pollution. The response is polite but clear about the issue.',
    example: 'Dear Neighbor, I hope this message finds you well. I\'m writing to discuss a matter that\'s been concerning me. The excessive noise during evenings is making it difficult for me to sleep. Would you be able to lower the volume after 10 PM? Thank you for your understanding.',
    tags: ['neighbor', 'noise', 'complaint', 'writing'],
    difficulty: DifficultyLevel.INTERMEDIATE,
    status: CardStatus.LEARNING,
    reviewCount: 3,
    correctCount: 2,
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date(),
    nextReviewDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000)
  },
  {
    id: '2',
    type: CardType.LISTENING,
    question: 'Listen to a conversation and answer the question: What is the main topic of discussion?',
    answer: 'The main topic is discussing weekend plans and activities.',
    explanation: 'This tests listening comprehension for identifying main ideas in conversations.',
    tags: ['listening', 'conversation', 'weekend plans', 'main idea'],
    difficulty: DifficultyLevel.BEGINNER,
    status: CardStatus.NEW,
    reviewCount: 0,
    correctCount: 0,
    createdAt: new Date('2024-01-02'),
    updatedAt: new Date()
  }
];

// GET /api/v1/cards/[id] - 获取单个卡片详情
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const card = mockFlashcards.find(c => c.id === id);

    if (!card) {
      const response: ApiResponse<never> = {
        success: false,
        error: {
          code: 'CARD_NOT_FOUND',
          message: `Card with ID ${id} not found`
        }
      };
      return NextResponse.json(response, { status: 404 });
    }

    const response: ApiResponse<Flashcard> = {
      success: true,
      data: card
    };

    return NextResponse.json(response, { status: 200 });
  } catch {
    const response: ApiResponse<never> = {
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Internal server error'
      }
    };
    return NextResponse.json(response, { status: 500 });
  }
}

// PUT /api/v1/cards/[id] - 更新卡片
export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id } = await params;
    const body = await request.json();

    // 验证请求体
    const updateSchema = z.object({
      title: z.string().min(1).max(255).optional(),
      scenario: z.string().min(1).optional(),
      tone: z.string().optional(),
      difficulty: z.nativeEnum(DifficultyLevel).optional(),
      status: z.nativeEnum(CardStatus).optional(),
      essentialPhrases: z.object({
        opening: z.array(z.string()),
        purpose: z.array(z.string()).optional(),
        details: z.array(z.string()).optional(),
        closing: z.array(z.string()).optional()
      }).optional(),
      upgrades: z.object({
        vocabulary: z.record(z.string(), z.array(z.string())),
        structure: z.record(z.string(), z.string()).optional()
      }).optional(),
      practice: z.object({
        question: z.string(),
        keyPoints: z.array(z.string())
      }).optional(),
      tags: z.array(z.string()).optional()
    });

    const validatedData = updateSchema.parse(body);

    const cardIndex = mockFlashcards.findIndex(c => c.id === id);

    if (cardIndex === -1) {
      const response: ApiResponse<never> = {
        success: false,
        error: {
          code: 'CARD_NOT_FOUND',
          message: `Card with ID ${id} not found`
        }
      };
      return NextResponse.json(response, { status: 404 });
    }

    // 更新卡片
    const updatedCard: Flashcard = {
      ...mockFlashcards[cardIndex],
      ...validatedData,
      updatedAt: new Date()
    };

    mockFlashcards[cardIndex] = updatedCard;

    const response: ApiResponse<Flashcard> = {
      success: true,
      data: updatedCard,
      message: 'Card updated successfully'
    };

    return NextResponse.json(response, { status: 200 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      const response: ApiResponse<never> = {
        success: false,
        error: {
          code: 'INVALID_REQUEST_BODY',
          message: 'Invalid request body format'
        }
      };
      return NextResponse.json(response, { status: 400 });
    }

    const response: ApiResponse<never> = {
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Internal server error'
      }
    };
    return NextResponse.json(response, { status: 500 });
  }
}

// DELETE /api/v1/cards/[id] - 删除卡片
export async function DELETE(
  request: NextRequest,
  { params: paramsPromise }: { params: Promise<{ id: string }> }
) {
  try {
    const params = await paramsPromise;
    const cardIndex = mockFlashcards.findIndex(c => c.id === params.id);

    if (cardIndex === -1) {
      const response: ApiResponse<never> = {
        success: false,
        error: {
          code: 'CARD_NOT_FOUND',
          message: `Card with ID ${params.id} not found`
        }
      };
      return NextResponse.json(response, { status: 404 });
    }

    // 软删除 - mark as mastered
    mockFlashcards[cardIndex].status = CardStatus.MASTERED;
    mockFlashcards[cardIndex].updatedAt = new Date();

    const response: ApiResponse<{ deleted: boolean }> = {
      success: true,
      data: { deleted: true },
      message: 'Card deleted successfully'
    };

    return NextResponse.json(response, { status: 200 });
  } catch {
    const response: ApiResponse<never> = {
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Internal server error'
      }
    };
    return NextResponse.json(response, { status: 500 });
  }
}
